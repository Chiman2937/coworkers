name: PR Coverage Report

on:
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  coverage:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: Debug - Check coverage files
        if: always()
        run: |
          echo "=== Working directory ==="
          pwd
          echo "=== All files ==="
          find . -name "coverage-summary.json" -type f
          echo "=== Coverage directory ==="
          ls -la coverage/ || echo "No coverage directory"
          echo "=== Coverage files ==="
          ls -la coverage/*.json || echo "No JSON files"

      - name: Download base coverage
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: coverage-base.yml
          branch: main
          name: base-coverage
          path: base-coverage
        continue-on-error: true

      - name: Create coverage report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Check if current coverage exists
            let currentCoverage;
            try {
              currentCoverage = JSON.parse(
                fs.readFileSync('coverage/coverage-summary.json', 'utf8')
              );
            } catch (error) {
              console.log('âŒ No coverage file generated. Tests may have failed.');
              
              // Post error comment
              const errorComment = `## Coverage Report
              
              âš ï¸ **Unable to generate coverage report**
              
              Coverage file not found. This usually means:
              - Tests failed to run
              - \`npm run test:coverage\` didn't generate coverage
              - Coverage directory is not created
              
              Please check the test execution logs above.`;
              
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('## ðŸ“Š Coverage Report')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: errorComment
                });
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: errorComment
                });
              }
              
              return; // Exit early
            }

            // Check if base coverage exists
            let baseCoverage;
            let isFirstRun = false;
            try {
              baseCoverage = JSON.parse(
                fs.readFileSync('base-coverage/coverage-summary.json', 'utf8')
              );
            } catch (error) {
              console.log('âš ï¸ No base coverage found. This is the first run.');
              isFirstRun = true;
              // Use empty baseline
              baseCoverage = { 
                total: { 
                  lines: { pct: 0, total: 0, covered: 0 },
                  branches: { total: 0 },
                  statements: { total: 0 },
                  functions: { total: 0 }
                } 
              };
            }

            const current = currentCoverage.total;
            const base = baseCoverage.total;

            // Calculate stats
            const currentIssueNumber = context.issue.number;

            const baseCoveragePercent = base.lines.pct;
            const currentCoveragePercent = current.lines.pct;
            const coveragePercentDiff = currentCoveragePercent - baseCoveragePercent;

            const baseFiles = Object.keys(baseCoverage).filter(key => key !== 'total').length;
            const currentFiles = Object.keys(currentCoverage).filter(key => key !== 'total').length;
            const filesDiff = currentFiles - baseFiles;

            const baseLines = base.lines.total;
            const currentLines = current.lines.total;
            const linesDiff = currentLines - baseLines;

            const baseBranches = base.branches.total;
            const currentBranches = current.branches.total;
            const branchesDiff = current.branches.total - base.branches.total;

            const baseHits = base.lines.covered;
            const currentHits = current.lines.covered;
            const hitsDiff = currentHits - baseHits;

            const baseMisses = base.lines.total - base.lines.covered;
            const currentMisses = current.lines.total - current.lines.covered;
            const missesDiff = currentMisses - baseMisses;

            // Header
            let header;
            if (isFirstRun) {
              header = `This is the first coverage report. Future PRs will show diff against this baseline.\n\nCurrent coverage: **${current.lines.pct.toFixed(2)}%**\n\n`;
            } else {
              const direction = coveragePercentDiff > 0 ? 'increase' : coveragePercentDiff < 0 ? 'decrease' : 'remain the same';
              const emoji = coveragePercentDiff > 0 ? 'ðŸ“ˆ' : coveragePercentDiff < 0 ? 'ðŸ“‰' : 'âž¡ï¸';
              header = `${emoji} Merging **#${context.issue.number}** into **main** will ${direction} coverage by \`${Math.abs(coveragePercentDiff).toFixed(2)}%\`.\n\n`;
            }

            // Coverage Diff Table
            const diffTable = `
            \`\`\`diff
            @@             Coverage Diff             @@
            ##             main   ${String('#' + currentIssueNumber).padStart(6)}       +/-   ##
            ===========================================
            ${coveragePercentDiff >= 0 ? '+' : '-'} Coverage   ${baseCoveragePercent.toFixed(2).padStart(5)}%   ${currentCoveragePercent.toFixed(2).padStart(5)}%   ${(coveragePercentDiff >= 0 ? '+' : '') + coveragePercentDiff.toFixed(2).padStart(5)}%     
            ===========================================
              Files      ${String(baseFiles).padStart(6)}   ${String(currentFiles).padStart(6)}   ${(filesDiff >= 0 ? '+' : '') + String(filesDiff).padStart(6)}
              Lines      ${String(baseLines).padStart(6)}   ${String(currentLines).padStart(6)}   ${(linesDiff >= 0 ? '+' : '') + String(linesDiff).padStart(6)}
              Branches   ${String(baseBranches).padStart(6)}   ${String(currentBranches).padStart(6)}   ${(branchesDiff >= 0 ? '+' : '') + String(branchesDiff).padStart(6)}
            ===========================================
            ${hitsDiff >= 0 ? '+' : '-'} Hits       ${String(baseHits).padStart(6)}   ${String(currentHits).padStart(6)}   ${(hitsDiff >= 0 ? '+' : '') + String(hitsDiff).padStart(6)}     
            ${missesDiff >= 0 ? '+' : '-'} Misses     ${String(baseMisses).padStart(6)}   ${String(currentMisses).padStart(6)}   ${(missesDiff >= 0 ? '+' : '') + String(missesDiff).padStart(6)}     
            \`\`\`
            `;

            // Impacted Files (skip for first run)
            let impactedTable = '';
            console.log('isFirstRun:', isFirstRun);
            console.log('Total files in current coverage:', Object.keys(currentCoverage).length);
            console.log('Total files in base coverage:', Object.keys(baseCoverage).length);

            if (isFirstRun) {
              impactedTable = '\n### Impacted Files\n\nðŸ“‹ **Baseline established**\n\nThis is the first coverage report. Future PRs will show which files are impacted by coverage changes.';
            } else {
              const impactedFiles = [];
              for (const file of Object.keys(currentCoverage)) {
                if (file === 'total') continue;
                if (file.includes('.test.') || file.includes('.spec.')) continue;
                
                const currentPct = currentCoverage[file]?.lines.pct || 0;
                const basePct = baseCoverage[file]?.lines.pct || 0;
                const diff = currentPct - basePct;
                
                if (Math.abs(diff) > 0.01) {
                  impactedFiles.push({
                    name: file,
                    current: currentPct.toFixed(2),
                    diff: diff.toFixed(2),
                    arrow: diff < -0.01 ? 'â¬‡ï¸' : diff > 0.01 ? 'â¬†ï¸' : 'âž¡ï¸'
                  });
                }
              }
              
              if (impactedFiles.length > 0) {
                impactedTable = '\n### Impacted Files\n\n| File | Coverage Î” |\n|------|------------|\n';
                impactedFiles.forEach(f => {
                  impactedTable += `| \`${f.name}\` | \`${f.current}% (${f.diff >= 0 ? '+' : ''}${f.diff}%)\` ${f.arrow} |\n`;
                });
              } else {
                impactedTable = '\n### Impacted Files\n\nâœ… **No files were impacted by this PR**\n\nAll modified files maintained their current coverage.';
              }
            }

            // Final comment
            const comment = `## ðŸ“Š Coverage Report\n\n${header}\n${diffTable}${impactedTable}`;

            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('## Coverage Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
