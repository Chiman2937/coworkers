name: PR Coverage Report

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  coverage:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests with coverage
        run: npm run test:coverage

      - name: Download base coverage
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: coverage-base.yml
          branch: main
          name: base-coverage
          path: base-coverage
        continue-on-error: true

      - name: Create coverage report
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Check if current coverage exists
            let currentCoverage;
            try {
              currentCoverage = JSON.parse(
                fs.readFileSync('coverage/coverage-summary.json', 'utf8')
              );
            } catch (error) {
              console.log('âŒ No coverage file generated. Tests may have failed.');
              
              // Post error comment
              const errorComment = `## Coverage Report
              
              âš ï¸ **Unable to generate coverage report**
              
              Coverage file not found. This usually means:
              - Tests failed to run
              - \`npm run test:coverage\` didn't generate coverage
              - Coverage directory is not created
              
              Please check the test execution logs above.`;
              
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              
              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('## Coverage Report')
              );
              
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: errorComment
                });
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: errorComment
                });
              }
              
              return; // Exit early
            }

            // Check if base coverage exists
            let baseCoverage;
            let isFirstRun = false;
            try {
              baseCoverage = JSON.parse(
                fs.readFileSync('base-coverage/coverage-summary.json', 'utf8')
              );
            } catch (error) {
              console.log('âš ï¸ No base coverage found. This is the first run.');
              isFirstRun = true;
              // Use empty baseline
              baseCoverage = { 
                total: { 
                  lines: { pct: 0, total: 0, covered: 0 },
                  branches: { total: 0 },
                  statements: { total: 0 },
                  functions: { total: 0 }
                } 
              };
            }

            const current = currentCoverage.total;
            const base = baseCoverage.total;

            // Calculate stats
            const coverageDiff = (current.lines.pct - base.lines.pct).toFixed(2);
            const linesDiff = current.lines.total - base.lines.total;
            const branchesDiff = current.branches.total - base.branches.total;
            const hitsDiff = current.lines.covered - base.lines.covered;
            const missesDiff = (current.lines.total - current.lines.covered) - (base.lines.total - base.lines.covered);

            // Header
            let header;
            if (isFirstRun) {
              header = `## ðŸ“Š First Coverage Report\n\nCurrent coverage: **${current.lines.pct.toFixed(2)}%**\n\n_This is the first coverage report. Future PRs will show diff against this baseline._`;
            } else {
              const direction = coverageDiff > 0 ? 'increase' : coverageDiff < 0 ? 'decrease' : 'remain the same';
              const emoji = coverageDiff > 0 ? 'ðŸ“ˆ' : coverageDiff < 0 ? 'ðŸ“‰' : 'âž¡ï¸';
              header = `${emoji} Merging **#${context.issue.number}** into **main** will ${direction} coverage by \`${Math.abs(coverageDiff)}%\`.`;
            }

            // Coverage Diff Table
            const diffTable = `
            \`\`\`diff
            @@            Coverage Diff             @@
            ##             main      #${context.issue.number.toString().padStart(6)}      +/-   ##
            ==========================================
            ${coverageDiff >= 0 ? '+' : '-'} Coverage   ${base.lines.pct.toFixed(2)}%   ${current.lines.pct.toFixed(2)}%   ${coverageDiff >= 0 ? '+' : ''}${coverageDiff}%     
            ==========================================
              Files          ${base.statements.total.toString().padStart(6)}   ${current.statements.total.toString().padStart(6)}   ${linesDiff >= 0 ? '+' : ''}${linesDiff}
              Lines          ${base.lines.total.toString().padStart(6)}   ${current.lines.total.toString().padStart(6)}   ${linesDiff >= 0 ? '+' : ''}${linesDiff}
              Branches       ${base.branches.total.toString().padStart(6)}   ${current.branches.total.toString().padStart(6)}   ${branchesDiff >= 0 ? '+' : ''}${branchesDiff}
            ==========================================
            ${hitsDiff >= 0 ? '+' : '-'} Hits           ${base.lines.covered.toString().padStart(6)}   ${current.lines.covered.toString().padStart(6)}   ${hitsDiff >= 0 ? '+' : ''}${hitsDiff}
            ${missesDiff >= 0 ? '+' : '-'} Misses         ${(base.lines.total - base.lines.covered).toString().padStart(6)}   ${(current.lines.total - current.lines.covered).toString().padStart(6)}   ${missesDiff >= 0 ? '+' : ''}${missesDiff}
            \`\`\`
            `;

            // Impacted Files (skip for first run)
            let impactedTable = '';
            if (!isFirstRun) {
              const impactedFiles = [];
              for (const file of Object.keys(currentCoverage)) {
                if (file === 'total') continue;
                if (file.includes('.test.') || file.includes('.spec.')) continue;
                
                const currentPct = currentCoverage[file]?.lines.pct || 0;
                const basePct = baseCoverage[file]?.lines.pct || 0;
                const diff = currentPct - basePct;
                
                if (Math.abs(diff) > 0.01) {
                  impactedFiles.push({
                    name: file,
                    current: currentPct.toFixed(2),
                    diff: diff.toFixed(2),
                    arrow: diff < -0.01 ? 'â¬‡ï¸' : diff > 0.01 ? 'â¬†ï¸' : 'âž¡ï¸'
                  });
                }
              }
              
              if (impactedFiles.length > 0) {
                impactedTable = '\n## Impacted Files\n\n| File | Coverage Î” |\n|------|------------|\n';
                impactedFiles.forEach(f => {
                  impactedTable += `| \`${f.name}\` | \`${f.current}% (${f.diff >= 0 ? '+' : ''}${f.diff}%)\` ${f.arrow} |\n`;
                });
              }
            }

            // Final comment
            const comment = `## Coverage Report\n\n${header}\n${diffTable}${impactedTable}`;

            // Find and update or create comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('## Coverage Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: comment
              });
            }
