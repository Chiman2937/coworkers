/**
 * Generated by orval v7.13.2 🍺
 * Do not edit manually.
 * coworkers-api
 * OpenAPI spec version: 1.0.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query';

import { httpClient } from '../../httpClient';
import type {
  CreateRecurringTasks200,
  ListTasksParams,
  Task,
  TaskRecurringCreateDto,
  TaskUpdateDto,
  UpdateTask200,
  UpdateTaskOrderBody,
} from '../../models';

/**
 * DEPRECATED: 여전히 동작합니다. 새로운 반복일정 생성 API를 제공합니다. \
아래 /{teamId}/groups/{groupId}/task-lists/{taskListId}/recurring 를 참고하세요

(반복)일정을 생성합니다.\
일종의 정책으로, 반복정책을 정하면, 해당 정책에 따라 할일이 생성됩니다.

할일(task)는 반복일정에 지정한 frequencyType에 따라 다르게 생성됩니다. \
ONCE: 한 번만 생성 (해당 일 조회시, 할일 존재) \
DAILY: 매일 생성 (시작일(startDate) 이후 어느 날짜를 조회해도 존재함) \
WEEKLY: 매주 생성 (시작일(startDate) 이후 해당 조건에 따라 존재) \
MONTHLY: 매월 생성 (시작일(startDate) 이후 해당 조건에 따라 존재)
 */
export const createRecurringTasks = (
  groupId: number,
  taskListId: number,
  taskRecurringCreateDto: TaskRecurringCreateDto,
  signal?: AbortSignal,
) => {
  return httpClient<CreateRecurringTasks200>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: taskRecurringCreateDto,
    signal,
  });
};

export const getCreateRecurringTasksMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRecurringTasks>>,
    TError,
    { groupId: number; taskListId: number; data: TaskRecurringCreateDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRecurringTasks>>,
  TError,
  { groupId: number; taskListId: number; data: TaskRecurringCreateDto },
  TContext
> => {
  const mutationKey = ['createRecurringTasks'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRecurringTasks>>,
    { groupId: number; taskListId: number; data: TaskRecurringCreateDto }
  > = (props) => {
    const { groupId, taskListId, data } = props ?? {};

    return createRecurringTasks(groupId, taskListId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateRecurringTasksMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRecurringTasks>>
>;
export type CreateRecurringTasksMutationBody = TaskRecurringCreateDto;
export type CreateRecurringTasksMutationError = unknown;

export const useCreateRecurringTasks = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createRecurringTasks>>,
      TError,
      { groupId: number; taskListId: number; data: TaskRecurringCreateDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createRecurringTasks>>,
  TError,
  { groupId: number; taskListId: number; data: TaskRecurringCreateDto },
  TContext
> => {
  const mutationOptions = getCreateRecurringTasksMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 특정 일자, 특정 할일 리스트의 할일 리스트
 */
export const listTasks = (
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  signal?: AbortSignal,
) => {
  return httpClient<Task[]>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks`,
    method: 'GET',
    params,
    signal,
  });
};

export const getListTasksQueryKey = (
  groupId?: number,
  taskListId?: number,
  params?: ListTasksParams,
) => {
  return [
    `/groups/${groupId}/task-lists/${taskListId}/tasks`,
    ...(params ? [params] : []),
  ] as const;
};

export const getListTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListTasksQueryKey(groupId, taskListId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listTasks>>> = ({ signal }) =>
    listTasks(groupId, taskListId, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(groupId && taskListId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type ListTasksQueryResult = NonNullable<Awaited<ReturnType<typeof listTasks>>>;
export type ListTasksQueryError = unknown;

export function useListTasks<TData = Awaited<ReturnType<typeof listTasks>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  params: undefined | ListTasksParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasks>>,
          TError,
          Awaited<ReturnType<typeof listTasks>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListTasks<TData = Awaited<ReturnType<typeof listTasks>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTasks>>,
          TError,
          Awaited<ReturnType<typeof listTasks>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListTasks<TData = Awaited<ReturnType<typeof listTasks>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListTasks<TData = Awaited<ReturnType<typeof listTasks>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListTasksQueryOptions(groupId, taskListId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchListTasksQuery = async <
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getListTasksQueryOptions(groupId, taskListId, params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListTasksSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListTasksQueryKey(groupId, taskListId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listTasks>>> = ({ signal }) =>
    listTasks(groupId, taskListId, params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListTasksSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof listTasks>>>;
export type ListTasksSuspenseQueryError = unknown;

export function useListTasksSuspense<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  params: undefined | ListTasksParams,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListTasksSuspense<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListTasksSuspense<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListTasksSuspense<
  TData = Awaited<ReturnType<typeof listTasks>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  params?: ListTasksParams,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof listTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListTasksSuspenseQueryOptions(groupId, taskListId, params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getTask = (
  groupId: number,
  taskListId: number,
  taskId: number,
  signal?: AbortSignal,
) => {
  return httpClient<Task>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks/${taskId}`,
    method: 'GET',
    signal,
  });
};

export const getGetTaskQueryKey = (groupId?: number, taskListId?: number, taskId?: number) => {
  return [`/groups/${groupId}/task-lists/${taskListId}/tasks/${taskId}`] as const;
};

export const getGetTaskQueryOptions = <
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTaskQueryKey(groupId, taskListId, taskId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({ signal }) =>
    getTask(groupId, taskListId, taskId, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!(groupId && taskListId && taskId),
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetTaskQueryResult = NonNullable<Awaited<ReturnType<typeof getTask>>>;
export type GetTaskQueryError = unknown;

export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTask>>,
          TError,
          Awaited<ReturnType<typeof getTask>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getTask>>,
          TError,
          Awaited<ReturnType<typeof getTask>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTask<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTaskQueryOptions(groupId, taskListId, taskId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetTaskQuery = async <
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetTaskQueryOptions(groupId, taskListId, taskId, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetTaskSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTask>>,
  TError = unknown,
>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetTaskQueryKey(groupId, taskListId, taskId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTask>>> = ({ signal }) =>
    getTask(groupId, taskListId, taskId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTask>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetTaskSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getTask>>>;
export type GetTaskSuspenseQueryError = unknown;

export function useGetTaskSuspense<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTaskSuspense<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetTaskSuspense<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetTaskSuspense<TData = Awaited<ReturnType<typeof getTask>>, TError = unknown>(
  groupId: number,
  taskListId: number,
  taskId: number,
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getTask>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetTaskSuspenseQueryOptions(groupId, taskListId, taskId, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateTask = (
  groupId: number,
  taskListId: number,
  taskId: number,
  taskUpdateDto: TaskUpdateDto,
) => {
  return httpClient<UpdateTask200>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks/${taskId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: taskUpdateDto,
  });
};

export const getUpdateTaskMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTask>>,
    TError,
    { groupId: number; taskListId: number; taskId: number; data: TaskUpdateDto },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTask>>,
  TError,
  { groupId: number; taskListId: number; taskId: number; data: TaskUpdateDto },
  TContext
> => {
  const mutationKey = ['updateTask'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTask>>,
    { groupId: number; taskListId: number; taskId: number; data: TaskUpdateDto }
  > = (props) => {
    const { groupId, taskListId, taskId, data } = props ?? {};

    return updateTask(groupId, taskListId, taskId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTaskMutationResult = NonNullable<Awaited<ReturnType<typeof updateTask>>>;
export type UpdateTaskMutationBody = TaskUpdateDto;
export type UpdateTaskMutationError = unknown;

export const useUpdateTask = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTask>>,
      TError,
      { groupId: number; taskListId: number; taskId: number; data: TaskUpdateDto },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTask>>,
  TError,
  { groupId: number; taskListId: number; taskId: number; data: TaskUpdateDto },
  TContext
> => {
  const mutationOptions = getUpdateTaskMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 특정 할일 삭제
 */
export const deleteTask = (groupId: number, taskListId: number, taskId: number) => {
  return httpClient<void>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks/${taskId}`,
    method: 'DELETE',
  });
};

export const getDeleteTaskMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTask>>,
    TError,
    { groupId: number; taskListId: number; taskId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTask>>,
  TError,
  { groupId: number; taskListId: number; taskId: number },
  TContext
> => {
  const mutationKey = ['deleteTask'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTask>>,
    { groupId: number; taskListId: number; taskId: number }
  > = (props) => {
    const { groupId, taskListId, taskId } = props ?? {};

    return deleteTask(groupId, taskListId, taskId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteTaskMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTask>>>;

export type DeleteTaskMutationError = unknown;

export const useDeleteTask = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteTask>>,
      TError,
      { groupId: number; taskListId: number; taskId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteTask>>,
  TError,
  { groupId: number; taskListId: number; taskId: number },
  TContext
> => {
  const mutationOptions = getDeleteTaskMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updateTaskOrder = (
  groupId: number,
  taskListId: number,
  id: number,
  updateTaskOrderBody: UpdateTaskOrderBody,
) => {
  return httpClient<void>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks/${id}/order`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateTaskOrderBody,
  });
};

export const getUpdateTaskOrderMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTaskOrder>>,
    TError,
    { groupId: number; taskListId: number; id: number; data: UpdateTaskOrderBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTaskOrder>>,
  TError,
  { groupId: number; taskListId: number; id: number; data: UpdateTaskOrderBody },
  TContext
> => {
  const mutationKey = ['updateTaskOrder'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTaskOrder>>,
    { groupId: number; taskListId: number; id: number; data: UpdateTaskOrderBody }
  > = (props) => {
    const { groupId, taskListId, id, data } = props ?? {};

    return updateTaskOrder(groupId, taskListId, id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateTaskOrderMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTaskOrder>>
>;
export type UpdateTaskOrderMutationBody = UpdateTaskOrderBody;
export type UpdateTaskOrderMutationError = unknown;

export const useUpdateTaskOrder = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateTaskOrder>>,
      TError,
      { groupId: number; taskListId: number; id: number; data: UpdateTaskOrderBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateTaskOrder>>,
  TError,
  { groupId: number; taskListId: number; id: number; data: UpdateTaskOrderBody },
  TContext
> => {
  const mutationOptions = getUpdateTaskOrderMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 반복할일 삭제
 */
export const deleteRecurringTask = (
  groupId: number,
  taskListId: number,
  taskId: number,
  recurringId: number,
) => {
  return httpClient<void>({
    url: `/groups/${groupId}/task-lists/${taskListId}/tasks/${taskId}/recurring/${recurringId}`,
    method: 'DELETE',
  });
};

export const getDeleteRecurringTaskMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRecurringTask>>,
    TError,
    { groupId: number; taskListId: number; taskId: number; recurringId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRecurringTask>>,
  TError,
  { groupId: number; taskListId: number; taskId: number; recurringId: number },
  TContext
> => {
  const mutationKey = ['deleteRecurringTask'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRecurringTask>>,
    { groupId: number; taskListId: number; taskId: number; recurringId: number }
  > = (props) => {
    const { groupId, taskListId, taskId, recurringId } = props ?? {};

    return deleteRecurringTask(groupId, taskListId, taskId, recurringId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteRecurringTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRecurringTask>>
>;

export type DeleteRecurringTaskMutationError = unknown;

export const useDeleteRecurringTask = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteRecurringTask>>,
      TError,
      { groupId: number; taskListId: number; taskId: number; recurringId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteRecurringTask>>,
  TError,
  { groupId: number; taskListId: number; taskId: number; recurringId: number },
  TContext
> => {
  const mutationOptions = getDeleteRecurringTaskMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
