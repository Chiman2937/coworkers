/**
 * Generated by orval v7.13.2 🍺
 * Do not edit manually.
 * coworkers-api
 * OpenAPI spec version: 1.0.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';

import { httpClient } from '../../httpClient';
import type {
  ArticleDetailType,
  ArticleListType,
  CreateArticleBody,
  DeleteArticle200,
  DeleteArticle403,
  DeleteArticle404,
  LikeArticle404,
  ListArticlesParams,
  OffsetBasedPaginationResponseArticleListType,
  RetrieveArticle404,
  UnlikeArticle404,
  UpdateArticle403,
  UpdateArticle404,
  UpdateArticleBody,
} from '../../models';

export const createArticle = (createArticleBody: CreateArticleBody, signal?: AbortSignal) => {
  return httpClient<ArticleListType>({
    url: `/articles`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createArticleBody,
    signal,
  });
};

export const getCreateArticleMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticle>>,
    TError,
    { data: CreateArticleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: CreateArticleBody },
  TContext
> => {
  const mutationKey = ['createArticle'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticle>>,
    { data: CreateArticleBody }
  > = (props) => {
    const { data } = props ?? {};

    return createArticle(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleMutationResult = NonNullable<Awaited<ReturnType<typeof createArticle>>>;
export type CreateArticleMutationBody = CreateArticleBody;
export type CreateArticleMutationError = unknown;

export const useCreateArticle = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createArticle>>,
      TError,
      { data: CreateArticleBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createArticle>>,
  TError,
  { data: CreateArticleBody },
  TContext
> => {
  const mutationOptions = getCreateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 게시글 목록 조회
 */
export const listArticles = (params?: ListArticlesParams, signal?: AbortSignal) => {
  return httpClient<OffsetBasedPaginationResponseArticleListType>({
    url: `/articles`,
    method: 'GET',
    params,
    signal,
  });
};

export const getListArticlesQueryKey = (params?: ListArticlesParams) => {
  return [`/articles`, ...(params ? [params] : [])] as const;
};

export const getListArticlesInfiniteQueryKey = (params?: ListArticlesParams) => {
  return ['infinate', `/articles`, ...(params ? [params] : [])] as const;
};

export const getListArticlesQueryOptions = <
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listArticles>>> = ({ signal }) =>
    listArticles(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArticlesQueryResult = NonNullable<Awaited<ReturnType<typeof listArticles>>>;
export type ListArticlesQueryError = unknown;

export function useListArticles<TData = Awaited<ReturnType<typeof listArticles>>, TError = unknown>(
  params: undefined | ListArticlesParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listArticles>>,
          TError,
          Awaited<ReturnType<typeof listArticles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticles<TData = Awaited<ReturnType<typeof listArticles>>, TError = unknown>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listArticles>>,
          TError,
          Awaited<ReturnType<typeof listArticles>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticles<TData = Awaited<ReturnType<typeof listArticles>>, TError = unknown>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListArticles<TData = Awaited<ReturnType<typeof listArticles>>, TError = unknown>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListArticlesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchListArticlesQuery = async <
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params?: ListArticlesParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getListArticlesQueryOptions(params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListArticlesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListArticlesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listArticles>>> = ({ signal }) =>
    listArticles(params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listArticles>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArticlesSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof listArticles>>>;
export type ListArticlesSuspenseQueryError = unknown;

export function useListArticlesSuspense<
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  params: undefined | ListArticlesParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticlesSuspense<
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticlesSuspense<
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListArticlesSuspense<
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticles>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListArticlesSuspenseQueryOptions(params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getListArticlesSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof listArticles>>, ListArticlesParams['page']>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticles>>,
        TError,
        TData,
        QueryKey,
        ListArticlesParams['page']
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListArticlesInfiniteQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listArticles>>,
    QueryKey,
    ListArticlesParams['page']
  > = ({ signal, pageParam }) =>
    listArticles({ ...params, page: pageParam || params?.['page'] }, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listArticles>>,
    TError,
    TData,
    QueryKey,
    ListArticlesParams['page']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArticlesSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof listArticles>>
>;
export type ListArticlesSuspenseInfiniteQueryError = unknown;

export function useListArticlesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listArticles>>, ListArticlesParams['page']>,
  TError = unknown,
>(
  params: undefined | ListArticlesParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticles>>,
        TError,
        TData,
        QueryKey,
        ListArticlesParams['page']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticlesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listArticles>>, ListArticlesParams['page']>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticles>>,
        TError,
        TData,
        QueryKey,
        ListArticlesParams['page']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticlesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listArticles>>, ListArticlesParams['page']>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticles>>,
        TError,
        TData,
        QueryKey,
        ListArticlesParams['page']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListArticlesSuspenseInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof listArticles>>, ListArticlesParams['page']>,
  TError = unknown,
>(
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticles>>,
        TError,
        TData,
        QueryKey,
        ListArticlesParams['page']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListArticlesSuspenseInfiniteQueryOptions(params, options);

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchListArticlesInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof listArticles>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  params?: ListArticlesParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticles>>,
        TError,
        TData,
        QueryKey,
        ListArticlesParams['page']
      >
    >;
  },
): Promise<QueryClient> => {
  const queryOptions = getListArticlesSuspenseInfiniteQueryOptions(params, options);

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

/**
 * 게시글 상세 조회
 */
export const retrieveArticle = (articleId: number, signal?: AbortSignal) => {
  return httpClient<ArticleDetailType>({ url: `/articles/${articleId}`, method: 'GET', signal });
};

export const getRetrieveArticleQueryKey = (articleId?: number) => {
  return [`/articles/${articleId}`] as const;
};

export const getRetrieveArticleQueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>>;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveArticleQueryKey(articleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveArticle>>> = ({ signal }) =>
    retrieveArticle(articleId, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof retrieveArticle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveArticleQueryResult = NonNullable<Awaited<ReturnType<typeof retrieveArticle>>>;
export type RetrieveArticleQueryError = RetrieveArticle404;

export function useRetrieveArticle<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveArticle>>,
          TError,
          Awaited<ReturnType<typeof retrieveArticle>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRetrieveArticle<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof retrieveArticle>>,
          TError,
          Awaited<ReturnType<typeof retrieveArticle>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRetrieveArticle<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useRetrieveArticle<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRetrieveArticleQueryOptions(articleId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchRetrieveArticleQuery = async <
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  queryClient: QueryClient,
  articleId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getRetrieveArticleQueryOptions(articleId, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getRetrieveArticleSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getRetrieveArticleQueryKey(articleId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof retrieveArticle>>> = ({ signal }) =>
    retrieveArticle(articleId, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof retrieveArticle>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type RetrieveArticleSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof retrieveArticle>>
>;
export type RetrieveArticleSuspenseQueryError = RetrieveArticle404;

export function useRetrieveArticleSuspense<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRetrieveArticleSuspense<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useRetrieveArticleSuspense<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useRetrieveArticleSuspense<
  TData = Awaited<ReturnType<typeof retrieveArticle>>,
  TError = RetrieveArticle404,
>(
  articleId: number,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof retrieveArticle>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getRetrieveArticleSuspenseQueryOptions(articleId, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 게시글 수정
 */
export const updateArticle = (articleId: number, updateArticleBody: UpdateArticleBody) => {
  return httpClient<ArticleDetailType>({
    url: `/articles/${articleId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateArticleBody,
  });
};

export const getUpdateArticleMutationOptions = <
  TError = UpdateArticle403 | UpdateArticle404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateArticle>>,
    TError,
    { articleId: number; data: UpdateArticleBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { articleId: number; data: UpdateArticleBody },
  TContext
> => {
  const mutationKey = ['updateArticle'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateArticle>>,
    { articleId: number; data: UpdateArticleBody }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return updateArticle(articleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateArticleMutationResult = NonNullable<Awaited<ReturnType<typeof updateArticle>>>;
export type UpdateArticleMutationBody = UpdateArticleBody;
export type UpdateArticleMutationError = UpdateArticle403 | UpdateArticle404;

export const useUpdateArticle = <TError = UpdateArticle403 | UpdateArticle404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateArticle>>,
      TError,
      { articleId: number; data: UpdateArticleBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateArticle>>,
  TError,
  { articleId: number; data: UpdateArticleBody },
  TContext
> => {
  const mutationOptions = getUpdateArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 게시글 삭제
 */
export const deleteArticle = (articleId: number) => {
  return httpClient<DeleteArticle200>({ url: `/articles/${articleId}`, method: 'DELETE' });
};

export const getDeleteArticleMutationOptions = <
  TError = DeleteArticle403 | DeleteArticle404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteArticle>>,
    TError,
    { articleId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationKey = ['deleteArticle'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteArticle>>,
    { articleId: number }
  > = (props) => {
    const { articleId } = props ?? {};

    return deleteArticle(articleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteArticleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteArticle>>>;

export type DeleteArticleMutationError = DeleteArticle403 | DeleteArticle404;

export const useDeleteArticle = <TError = DeleteArticle403 | DeleteArticle404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteArticle>>,
      TError,
      { articleId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationOptions = getDeleteArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 게시글 좋아요
 */
export const likeArticle = (articleId: number, signal?: AbortSignal) => {
  return httpClient<ArticleDetailType>({
    url: `/articles/${articleId}/like`,
    method: 'POST',
    signal,
  });
};

export const getLikeArticleMutationOptions = <
  TError = LikeArticle404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof likeArticle>>,
    TError,
    { articleId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof likeArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationKey = ['likeArticle'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof likeArticle>>,
    { articleId: number }
  > = (props) => {
    const { articleId } = props ?? {};

    return likeArticle(articleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type LikeArticleMutationResult = NonNullable<Awaited<ReturnType<typeof likeArticle>>>;

export type LikeArticleMutationError = LikeArticle404;

export const useLikeArticle = <TError = LikeArticle404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof likeArticle>>,
      TError,
      { articleId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof likeArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationOptions = getLikeArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 게시글 좋아요 취소
 */
export const unlikeArticle = (articleId: number) => {
  return httpClient<ArticleDetailType>({ url: `/articles/${articleId}/like`, method: 'DELETE' });
};

export const getUnlikeArticleMutationOptions = <
  TError = UnlikeArticle404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof unlikeArticle>>,
    TError,
    { articleId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof unlikeArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationKey = ['unlikeArticle'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof unlikeArticle>>,
    { articleId: number }
  > = (props) => {
    const { articleId } = props ?? {};

    return unlikeArticle(articleId);
  };

  return { mutationFn, ...mutationOptions };
};

export type UnlikeArticleMutationResult = NonNullable<Awaited<ReturnType<typeof unlikeArticle>>>;

export type UnlikeArticleMutationError = UnlikeArticle404;

export const useUnlikeArticle = <TError = UnlikeArticle404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof unlikeArticle>>,
      TError,
      { articleId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof unlikeArticle>>,
  TError,
  { articleId: number },
  TContext
> => {
  const mutationOptions = getUnlikeArticleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
