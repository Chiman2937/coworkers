/**
 * Generated by orval v7.13.2 🍺
 * Do not edit manually.
 * coworkers-api
 * OpenAPI spec version: 1.0.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import { useMutation, useQuery, useSuspenseQuery } from '@tanstack/react-query';

import { httpClient } from '../../httpClient';
import type {
  GetGroups200Item,
  GetMemberships200Item,
  GetUser200,
  ListDoneTasks200,
  PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword,
  ResetPassword200,
  ResetPasswordBody,
  SendResetPasswordEmail200,
  SendResetPasswordEmailRequest,
  UpdateMe200,
  UpdatePassword200,
  UpdatePasswordBody,
} from '../../models';

export const getUser = (signal?: AbortSignal) => {
  return httpClient<GetUser200>({ url: `/user`, method: 'GET', signal });
};

export const getGetUserQueryKey = () => {
  return [`/user`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) =>
    getUser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type GetUserQueryError = unknown;

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUser>>,
          TError,
          Awaited<ReturnType<typeof getUser>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetUser<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetUserQuery = async <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetUserQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({ signal }) =>
    getUser(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUserSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getUser>>>;
export type GetUserSuspenseQueryError = unknown;

export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetUserSuspense<TData = Awaited<ReturnType<typeof getUser>>, TError = unknown>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const updateMe = (
  pickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword: PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword,
) => {
  return httpClient<UpdateMe200>({
    url: `/user`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: pickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword,
  });
};

export const getUpdateMeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMe>>,
    TError,
    { data: PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMe>>,
  TError,
  { data: PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword },
  TContext
> => {
  const mutationKey = ['updateMe'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMe>>,
    { data: PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword }
  > = (props) => {
    const { data } = props ?? {};

    return updateMe(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMeMutationResult = NonNullable<Awaited<ReturnType<typeof updateMe>>>;
export type UpdateMeMutationBody = PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword;
export type UpdateMeMutationError = unknown;

export const useUpdateMe = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMe>>,
      TError,
      { data: PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateMe>>,
  TError,
  { data: PickUpdateUserBodyExcludeKeyofUpdateUserBodyEncryptedPassword },
  TContext
> => {
  const mutationOptions = getUpdateMeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 회원 탈퇴
 */
export const deleteMe = () => {
  return httpClient<void>({ url: `/user`, method: 'DELETE' });
};

export const getDeleteMeMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteMe>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<typeof deleteMe>>, TError, void, TContext> => {
  const mutationKey = ['deleteMe'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteMe>>, void> = () => {
    return deleteMe();
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteMe>>>;

export type DeleteMeMutationError = unknown;

export const useDeleteMe = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteMe>>, TError, void, TContext>;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof deleteMe>>, TError, void, TContext> => {
  const mutationOptions = getDeleteMeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const getGroups = (signal?: AbortSignal) => {
  return httpClient<GetGroups200Item[]>({ url: `/user/groups`, method: 'GET', signal });
};

export const getGetGroupsQueryKey = () => {
  return [`/user/groups`] as const;
};

export const getGetGroupsQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroups>>> = ({ signal }) =>
    getGroups(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGroups>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupsQueryResult = NonNullable<Awaited<ReturnType<typeof getGroups>>>;
export type GetGroupsQueryError = unknown;

export function useGetGroups<TData = Awaited<ReturnType<typeof getGroups>>, TError = unknown>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroups>>,
          TError,
          Awaited<ReturnType<typeof getGroups>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetGroups<TData = Awaited<ReturnType<typeof getGroups>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGroups>>,
          TError,
          Awaited<ReturnType<typeof getGroups>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetGroups<TData = Awaited<ReturnType<typeof getGroups>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetGroups<TData = Awaited<ReturnType<typeof getGroups>>, TError = unknown>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGroupsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetGroupsQuery = async <
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetGroupsQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetGroupsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGroupsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGroups>>> = ({ signal }) =>
    getGroups(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGroups>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGroupsSuspenseQueryResult = NonNullable<Awaited<ReturnType<typeof getGroups>>>;
export type GetGroupsSuspenseQueryError = unknown;

export function useGetGroupsSuspense<
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetGroupsSuspense<
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetGroupsSuspense<
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetGroupsSuspense<
  TData = Awaited<ReturnType<typeof getGroups>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseSuspenseQueryOptions<Awaited<ReturnType<typeof getGroups>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetGroupsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getMemberships = (signal?: AbortSignal) => {
  return httpClient<GetMemberships200Item[]>({ url: `/user/memberships`, method: 'GET', signal });
};

export const getGetMembershipsQueryKey = () => {
  return [`/user/memberships`] as const;
};

export const getGetMembershipsQueryOptions = <
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMembershipsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemberships>>> = ({ signal }) =>
    getMemberships(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMemberships>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMembershipsQueryResult = NonNullable<Awaited<ReturnType<typeof getMemberships>>>;
export type GetMembershipsQueryError = unknown;

export function useGetMemberships<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemberships>>,
          TError,
          Awaited<ReturnType<typeof getMemberships>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMemberships<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemberships>>,
          TError,
          Awaited<ReturnType<typeof getMemberships>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMemberships<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetMemberships<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMembershipsQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchGetMembershipsQuery = async <
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getGetMembershipsQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getGetMembershipsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMembershipsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemberships>>> = ({ signal }) =>
    getMemberships(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getMemberships>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMembershipsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMemberships>>
>;
export type GetMembershipsSuspenseQueryError = unknown;

export function useGetMembershipsSuspense<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMembershipsSuspense<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetMembershipsSuspense<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useGetMembershipsSuspense<
  TData = Awaited<ReturnType<typeof getMemberships>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof getMemberships>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetMembershipsSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 완료한 작업 조회
 */
export const listDoneTasks = (signal?: AbortSignal) => {
  return httpClient<ListDoneTasks200>({ url: `/user/history`, method: 'GET', signal });
};

export const getListDoneTasksQueryKey = () => {
  return [`/user/history`] as const;
};

export const getListDoneTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>>;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListDoneTasksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listDoneTasks>>> = ({ signal }) =>
    listDoneTasks(signal);

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listDoneTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListDoneTasksQueryResult = NonNullable<Awaited<ReturnType<typeof listDoneTasks>>>;
export type ListDoneTasksQueryError = unknown;

export function useListDoneTasks<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDoneTasks>>,
          TError,
          Awaited<ReturnType<typeof listDoneTasks>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListDoneTasks<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDoneTasks>>,
          TError,
          Awaited<ReturnType<typeof listDoneTasks>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListDoneTasks<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListDoneTasks<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListDoneTasksQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchListDoneTasksQuery = async <
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  queryClient: QueryClient,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>>;
  },
): Promise<QueryClient> => {
  const queryOptions = getListDoneTasksQueryOptions(options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListDoneTasksSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>
  >;
}) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListDoneTasksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listDoneTasks>>> = ({ signal }) =>
    listDoneTasks(signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listDoneTasks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListDoneTasksSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof listDoneTasks>>
>;
export type ListDoneTasksSuspenseQueryError = unknown;

export function useListDoneTasksSuspense<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListDoneTasksSuspense<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListDoneTasksSuspense<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListDoneTasksSuspense<
  TData = Awaited<ReturnType<typeof listDoneTasks>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listDoneTasks>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListDoneTasksSuspenseQueryOptions(options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * 비밀번호 재설정 이메일 전송
- {redirectUrl}/reset-password?token=${token}로 이동할 수 있는 링크를 이메일로 전송합니다.
  e.g. "https://coworkers.vercel.app/reset-password?token=1234567890"
 */
export const sendResetPasswordEmail = (
  sendResetPasswordEmailRequest: SendResetPasswordEmailRequest,
  signal?: AbortSignal,
) => {
  return httpClient<SendResetPasswordEmail200>({
    url: `/user/send-reset-password-email`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: sendResetPasswordEmailRequest,
    signal,
  });
};

export const getSendResetPasswordEmailMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof sendResetPasswordEmail>>,
    TError,
    { data: SendResetPasswordEmailRequest },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof sendResetPasswordEmail>>,
  TError,
  { data: SendResetPasswordEmailRequest },
  TContext
> => {
  const mutationKey = ['sendResetPasswordEmail'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof sendResetPasswordEmail>>,
    { data: SendResetPasswordEmailRequest }
  > = (props) => {
    const { data } = props ?? {};

    return sendResetPasswordEmail(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type SendResetPasswordEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof sendResetPasswordEmail>>
>;
export type SendResetPasswordEmailMutationBody = SendResetPasswordEmailRequest;
export type SendResetPasswordEmailMutationError = unknown;

export const useSendResetPasswordEmail = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof sendResetPasswordEmail>>,
      TError,
      { data: SendResetPasswordEmailRequest },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof sendResetPasswordEmail>>,
  TError,
  { data: SendResetPasswordEmailRequest },
  TContext
> => {
  const mutationOptions = getSendResetPasswordEmailMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 이메일로 전달받은 링크에서 비밀번호 초기화
- POST user/send-reset-password-email 요청으로 발송한 메일의 링크에 담긴 토큰을 사용해야 합니다.
 */
export const resetPassword = (resetPasswordBody: ResetPasswordBody) => {
  return httpClient<ResetPassword200>({
    url: `/user/reset-password`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: resetPasswordBody,
  });
};

export const getResetPasswordMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof resetPassword>>,
    TError,
    { data: ResetPasswordBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof resetPassword>>,
  TError,
  { data: ResetPasswordBody },
  TContext
> => {
  const mutationKey = ['resetPassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof resetPassword>>,
    { data: ResetPasswordBody }
  > = (props) => {
    const { data } = props ?? {};

    return resetPassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type ResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof resetPassword>>>;
export type ResetPasswordMutationBody = ResetPasswordBody;
export type ResetPasswordMutationError = unknown;

export const useResetPassword = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof resetPassword>>,
      TError,
      { data: ResetPasswordBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof resetPassword>>,
  TError,
  { data: ResetPasswordBody },
  TContext
> => {
  const mutationOptions = getResetPasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
export const updatePassword = (updatePasswordBody: UpdatePasswordBody) => {
  return httpClient<UpdatePassword200>({
    url: `/user/password`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updatePasswordBody,
  });
};

export const getUpdatePasswordMutationOptions = <TError = unknown, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePassword>>,
    TError,
    { data: UpdatePasswordBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePassword>>,
  TError,
  { data: UpdatePasswordBody },
  TContext
> => {
  const mutationKey = ['updatePassword'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePassword>>,
    { data: UpdatePasswordBody }
  > = (props) => {
    const { data } = props ?? {};

    return updatePassword(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePasswordMutationResult = NonNullable<Awaited<ReturnType<typeof updatePassword>>>;
export type UpdatePasswordMutationBody = UpdatePasswordBody;
export type UpdatePasswordMutationError = unknown;

export const useUpdatePassword = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePassword>>,
      TError,
      { data: UpdatePasswordBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePassword>>,
  TError,
  { data: UpdatePasswordBody },
  TContext
> => {
  const mutationOptions = getUpdatePasswordMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
