/**
 * Generated by orval v7.13.2 🍺
 * Do not edit manually.
 * coworkers-api
 * OpenAPI spec version: 1.0.0
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseInfiniteQueryOptions,
  UseSuspenseInfiniteQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query';
import {
  useMutation,
  useQuery,
  useSuspenseInfiniteQuery,
  useSuspenseQuery,
} from '@tanstack/react-query';

import { httpClient } from '../../httpClient';
import type {
  CommentType,
  CreateArticleComment404,
  CreateCommentBody,
  CursorBasedPaginationResponseCommentType,
  DeleteComment200,
  DeleteComment403,
  DeleteComment404,
  ListArticleComments404,
  ListArticleCommentsParams,
  UpdateComment403,
  UpdateComment404,
  UpdateCommentBody,
} from '../../models';

/**
 * 게시글의 댓글 작성
 */
export const createArticleComment = (
  articleId: number,
  createCommentBody: CreateCommentBody,
  signal?: AbortSignal,
) => {
  return httpClient<CommentType>({
    url: `/articles/${articleId}/comments`,
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    data: createCommentBody,
    signal,
  });
};

export const getCreateArticleCommentMutationOptions = <
  TError = CreateArticleComment404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createArticleComment>>,
    TError,
    { articleId: number; data: CreateCommentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createArticleComment>>,
  TError,
  { articleId: number; data: CreateCommentBody },
  TContext
> => {
  const mutationKey = ['createArticleComment'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createArticleComment>>,
    { articleId: number; data: CreateCommentBody }
  > = (props) => {
    const { articleId, data } = props ?? {};

    return createArticleComment(articleId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateArticleCommentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createArticleComment>>
>;
export type CreateArticleCommentMutationBody = CreateCommentBody;
export type CreateArticleCommentMutationError = CreateArticleComment404;

export const useCreateArticleComment = <TError = CreateArticleComment404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createArticleComment>>,
      TError,
      { articleId: number; data: CreateCommentBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createArticleComment>>,
  TError,
  { articleId: number; data: CreateCommentBody },
  TContext
> => {
  const mutationOptions = getCreateArticleCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 게시글의 댓글 목록 조회
 */
export const listArticleComments = (
  articleId: number,
  params: ListArticleCommentsParams,
  signal?: AbortSignal,
) => {
  return httpClient<CursorBasedPaginationResponseCommentType>({
    url: `/articles/${articleId}/comments`,
    method: 'GET',
    params,
    signal,
  });
};

export const getListArticleCommentsQueryKey = (
  articleId?: number,
  params?: ListArticleCommentsParams,
) => {
  return [`/articles/${articleId}/comments`, ...(params ? [params] : [])] as const;
};

export const getListArticleCommentsInfiniteQueryKey = (
  articleId?: number,
  params?: ListArticleCommentsParams,
) => {
  return ['infinate', `/articles/${articleId}/comments`, ...(params ? [params] : [])] as const;
};

export const getListArticleCommentsQueryOptions = <
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListArticleCommentsQueryKey(articleId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listArticleComments>>> = ({ signal }) =>
    listArticleComments(articleId, params, signal);

  return { queryKey, queryFn, enabled: !!articleId, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof listArticleComments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArticleCommentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof listArticleComments>>
>;
export type ListArticleCommentsQueryError = ListArticleComments404;

export function useListArticleComments<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listArticleComments>>,
          TError,
          Awaited<ReturnType<typeof listArticleComments>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticleComments<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listArticleComments>>,
          TError,
          Awaited<ReturnType<typeof listArticleComments>>
        >,
        'initialData'
      >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticleComments<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListArticleComments<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListArticleCommentsQueryOptions(articleId, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchListArticleCommentsQuery = async <
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  queryClient: QueryClient,
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
): Promise<QueryClient> => {
  const queryOptions = getListArticleCommentsQueryOptions(articleId, params, options);

  await queryClient.prefetchQuery(queryOptions);

  return queryClient;
};

export const getListArticleCommentsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getListArticleCommentsQueryKey(articleId, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof listArticleComments>>> = ({ signal }) =>
    listArticleComments(articleId, params, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof listArticleComments>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArticleCommentsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof listArticleComments>>
>;
export type ListArticleCommentsSuspenseQueryError = ListArticleComments404;

export function useListArticleCommentsSuspense<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options: {
    query: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticleCommentsSuspense<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticleCommentsSuspense<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListArticleCommentsSuspense<
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<Awaited<ReturnType<typeof listArticleComments>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListArticleCommentsSuspenseQueryOptions(articleId, params, options);

  const query = useSuspenseQuery(queryOptions, queryClient) as UseSuspenseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getListArticleCommentsSuspenseInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof listArticleComments>>,
    ListArticleCommentsParams['cursor']
  >,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticleComments>>,
        TError,
        TData,
        QueryKey,
        ListArticleCommentsParams['cursor']
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getListArticleCommentsInfiniteQueryKey(articleId, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof listArticleComments>>,
    QueryKey,
    ListArticleCommentsParams['cursor']
  > = ({ signal, pageParam }) =>
    listArticleComments(articleId, { ...params, cursor: pageParam || params?.['cursor'] }, signal);

  return { queryKey, queryFn, ...queryOptions } as UseSuspenseInfiniteQueryOptions<
    Awaited<ReturnType<typeof listArticleComments>>,
    TError,
    TData,
    QueryKey,
    ListArticleCommentsParams['cursor']
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ListArticleCommentsSuspenseInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof listArticleComments>>
>;
export type ListArticleCommentsSuspenseInfiniteQueryError = ListArticleComments404;

export function useListArticleCommentsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof listArticleComments>>,
    ListArticleCommentsParams['cursor']
  >,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options: {
    query: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticleComments>>,
        TError,
        TData,
        QueryKey,
        ListArticleCommentsParams['cursor']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticleCommentsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof listArticleComments>>,
    ListArticleCommentsParams['cursor']
  >,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticleComments>>,
        TError,
        TData,
        QueryKey,
        ListArticleCommentsParams['cursor']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useListArticleCommentsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof listArticleComments>>,
    ListArticleCommentsParams['cursor']
  >,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticleComments>>,
        TError,
        TData,
        QueryKey,
        ListArticleCommentsParams['cursor']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useListArticleCommentsSuspenseInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof listArticleComments>>,
    ListArticleCommentsParams['cursor']
  >,
  TError = ListArticleComments404,
>(
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticleComments>>,
        TError,
        TData,
        QueryKey,
        ListArticleCommentsParams['cursor']
      >
    >;
  },
  queryClient?: QueryClient,
): UseSuspenseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getListArticleCommentsSuspenseInfiniteQueryOptions(
    articleId,
    params,
    options,
  );

  const query = useSuspenseInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseSuspenseInfiniteQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const prefetchListArticleCommentsInfiniteQuery = async <
  TData = Awaited<ReturnType<typeof listArticleComments>>,
  TError = ListArticleComments404,
>(
  queryClient: QueryClient,
  articleId: number,
  params: ListArticleCommentsParams,
  options?: {
    query?: Partial<
      UseSuspenseInfiniteQueryOptions<
        Awaited<ReturnType<typeof listArticleComments>>,
        TError,
        TData,
        QueryKey,
        ListArticleCommentsParams['cursor']
      >
    >;
  },
): Promise<QueryClient> => {
  const queryOptions = getListArticleCommentsSuspenseInfiniteQueryOptions(
    articleId,
    params,
    options,
  );

  await queryClient.prefetchInfiniteQuery(queryOptions);

  return queryClient;
};

/**
 * 댓글 수정
 */
export const updateComment = (commentId: number, updateCommentBody: UpdateCommentBody) => {
  return httpClient<CommentType>({
    url: `/comments/${commentId}`,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    data: updateCommentBody,
  });
};

export const getUpdateCommentMutationOptions = <
  TError = UpdateComment403 | UpdateComment404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateComment>>,
    TError,
    { commentId: number; data: UpdateCommentBody },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateComment>>,
  TError,
  { commentId: number; data: UpdateCommentBody },
  TContext
> => {
  const mutationKey = ['updateComment'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateComment>>,
    { commentId: number; data: UpdateCommentBody }
  > = (props) => {
    const { commentId, data } = props ?? {};

    return updateComment(commentId, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof updateComment>>>;
export type UpdateCommentMutationBody = UpdateCommentBody;
export type UpdateCommentMutationError = UpdateComment403 | UpdateComment404;

export const useUpdateComment = <TError = UpdateComment403 | UpdateComment404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateComment>>,
      TError,
      { commentId: number; data: UpdateCommentBody },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateComment>>,
  TError,
  { commentId: number; data: UpdateCommentBody },
  TContext
> => {
  const mutationOptions = getUpdateCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * 댓글 삭제
 */
export const deleteComment = (commentId: number) => {
  return httpClient<DeleteComment200>({ url: `/comments/${commentId}`, method: 'DELETE' });
};

export const getDeleteCommentMutationOptions = <
  TError = DeleteComment403 | DeleteComment404,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteComment>>,
    TError,
    { commentId: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteComment>>,
  TError,
  { commentId: number },
  TContext
> => {
  const mutationKey = ['deleteComment'];
  const { mutation: mutationOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteComment>>,
    { commentId: number }
  > = (props) => {
    const { commentId } = props ?? {};

    return deleteComment(commentId);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteCommentMutationResult = NonNullable<Awaited<ReturnType<typeof deleteComment>>>;

export type DeleteCommentMutationError = DeleteComment403 | DeleteComment404;

export const useDeleteComment = <TError = DeleteComment403 | DeleteComment404, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteComment>>,
      TError,
      { commentId: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteComment>>,
  TError,
  { commentId: number },
  TContext
> => {
  const mutationOptions = getDeleteCommentMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
